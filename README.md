[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18376386&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is a process of designing, developing, testing and maintaining software applications.

Identify and describe at least three key milestones in the evolution of software engineering.
- Version Control: To able to control and manage source code.
- Prompt Engineering: AI that supports your work and provides you insights.
- OOP: Object Oriented Programming was developed to help write codes by not worrying about the low-level code


List and briefly explain the phases of the Software Development Life Cycle.
- Planning: The initial phase of the SDLC
- Requirements analysis: Involves analyzing the needs of the user
- Design: Involves designing the architecture of the product
- Coding: Involves writing the code for the software
- Testing: Involves testing the software to ensure it meets quality and functionality standards
- Deployment: Involves making the software available for use
- Maintenance: Involves maintaining and supporting the software after it's deployed


Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
A "waterfall" methodology is a linear, sequential project management approach where each phase must be fully completed before moving to the next, while an "agile" methodology is a flexible, iterative approach that emphasizes continuous adaptation and collaboration, allowing for changes throughout the development process by breaking projects into smaller, manageable units of work. 
Key differences between Waterfall and Agile:

    Flexibility:
    Waterfall is rigid and less adaptable to change, while Agile encourages adjustments based on feedback throughout the project. 

Planning:
Waterfall requires extensive upfront planning with detailed requirements before development begins, whereas Agile focuses on iterative planning with frequent adjustments. 
Delivery:
In Waterfall, the final product is delivered at the end of the project, while Agile delivers working increments of the product regularly throughout the development cycle. 
Customer involvement:
Waterfall typically has less customer involvement during development, while Agile actively engages the customer for feedback and prioritization. 

Some popular Agile frameworks include:

    Scrum:
    Emphasizes time-boxed "sprints" with cross-functional teams working collaboratively to deliver incremental value. 

Kanban:
A visual system for managing workflow, focusing on limiting work in progress and optimizing flow. 
Extreme Programming (XP):
Prioritizes customer satisfaction and technical excellence through practices like pair programming and frequent releases. 

When to use Waterfall:

    Projects with well-defined requirements and minimal expected changes.
    Projects where strict documentation and compliance are essential. 

When to use Agile:

    Projects with uncertain requirements or potential for frequent changes.
    Projects requiring rapid development and frequent feedback from stakeholders. 


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

- Software developer is the one who implements and builds the applications
- Quality Assurance Engineer is the one who test the application to see if it meets
- Project Manager is the one who oversees the project, assign tasks, solve conflicts


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
- IDE: it is a software that is used writing the code. (VSCode)
- VCS: helps in controlling and organising source code. (git)

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
1. Keeping Up with Rapidly Changing Technologies
 - Focus on fundamentals – Strong CS concepts (data structures, algorithms, system design) matter more than tools.
2. Imposter Syndrome & Self-Doubt
 - Track your progress – Keep a "wins" journal of solved problems and contributions.
3. Debugging Complex Code & Handling Bugs
 - Use structured debugging – Start by understanding the error message, then isolate issues step-by-step.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
1. Unit Testing : Unit testing focuses on testing individual components or functions of the software in isolation. It ensures that each function, method, or module works as expected before integrating it with other parts of the system.
2. Integration Testing: Integration testing checks how multiple modules, services, or APIs interact when combined. It ensures that different components work together correctly when integrated.
3. System Testing:System testing evaluates the entire application as a whole to ensure it meets functional and non-functional requirements.
4. Acceptance Testing: Acceptance testing determines whether the software meets business and user requirements before deployment. It is performed by end users to verify if the system meets their needs.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the practice of designing and optimizing inputs (prompts) to effectively interact with AI models, such as ChatGPT, Stable Diffusion, or other large language models (LLMs). It involves crafting clear, precise, and structured prompts to get accurate, relevant, and useful responses from AI systems.
Key Aspects of Prompt Engineering:

    Clarity & Specificity – Well-defined prompts lead to better AI-generated responses.
    Context Awareness – Providing background information improves response quality.
    Formatting & Structure – Using bullet points, step-by-step instructions, or examples enhances AI understanding.
    Constraints & Guidelines – Specifying length, style, or format helps refine responses.
    Iteration & Optimization – Testing and refining prompts to improve accuracy.


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Example of a Vague Prompt:

❌ "Tell me about AI."
Improved Prompt:

✅ "Explain how AI is transforming the software development industry. Provide three real-world examples and discuss the benefits and challenges."
Why is the Improved Prompt More Effective?

    Clearer Intent – Instead of a broad request, it specifies the focus on software development.
    More Specific Output – It asks for three real-world examples, ensuring concrete and practical insights.
    Balanced Perspective – By requesting both benefits and challenges, it avoids a one-sided response.
    Concise & Actionable – The AI knows exactly what details to include, making the response more relevant and structured.
